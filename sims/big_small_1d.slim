function (*) diff(numeric x) {
	return x[1:(length(x) - 1)] - x[0:(length(x) - 2)];
}

function (*) InitLandscape(numeric n) {
	x = rep(0.0, n);
	x[0] = asFloat(runif(1) < PBAD / (PBAD + PGOOD));
	for (k in 1:(n-1)) {
		p = (x[k-1] == 0) ? PBAD else 1 - PGOOD;
		x[k] = asFloat(runif(1) < p);
	}
	return x;
}

function (*) UpdateLandscape(numeric x) {
	n = length(x);
	lefts = which(diff(c(0, x)) > 0);
	rights = which(diff(c(x, 0)) < 0);
	np = size(lefts);
	if (np > 0) {
		gaps = c(lefts, n) - c(-1, rights) - 1;
		ones = (lefts == rights);
		for (k in seq(0, np-1)) {
			// die?
			if (ones[k] & (runif(1) < PATCHDEATH)) {
				x[lefts[k]] = 0;
			} else { // jitter?
				if (runif(1) < JITTER) { // left boundary
					if (runif(1) < GROW_PROB) { // grow?
						if (gaps[k] > 1)
							x[lefts[k] - 1] = 1.0;
					} else { // shrink?
						if (!ones[k])
							x[lefts[k]] = 0.0;
					}
				}
				if (runif(1) < JITTER) { // right boundary
					if (runif(1) < GROW_PROB) { // grow
						if (gaps[k+1] > 1)
							x[rights[k] + 1] = 1.0;
					} else { // shrink?
						if (!ones[k])
							x[rights[k]] = 0.0;
					}
				}
			}
		}
	}
	// births
	lefts = which(diff(c(0, x)) > 0);
	rights = which(diff(c(x, 0)) < 0);
	np = size(lefts);
	gaps = c(lefts, n) - c(-1, rights) - 1;
	for (k in seq(0, length(gaps) - 1)) {
		if (gaps[k] > 2) {
			nb = rpois(1, PATCHBIRTH * (gaps[k] - 2));
			start = c(-1, rights)[k] + 2;
			end = c(lefts, n)[k] - 2;
			locs = sample(start:end, nb);
			x[locs] = 1.0;
		}
	}
	return x;
}

initialize() {
	setSeed(5);
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="x");
	initializeTreeSeq();
	
	defineConstant("K", 5);  // carrying-capacity per unit area (roughly)
	defineConstant("SD", 1.0);  // sigma_D, the dispersal distance
	defineConstant("SI", 1.0);  // sigma_I, the spatial interaction distance
	defineConstant("SM", SI);  // sigma_M, the mate choice distance
	defineConstant("L", 4);    // mean lifetime at stationarity
	defineConstant("W", 1000.0);  // dimension of the simulated area
	defineConstant("G", 1e8);  // genome length
	defineConstant("FECUN", 1/L); // mean fecundity
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	
	defineConstant("PGOOD", 0.1); // mean length of a patch is 1/PGOOD
	defineConstant("PBAD", 0.01); // mean length of inter-patch is 1/PBAD
	defineConstant("GAMMA_B", 0.2); // relative rate of births/deaths
	defineConstant("PATCHBIRTH", GAMMA_B * PBAD * PGOOD / (1 - PBAD));
	defineConstant("PATCHDEATH", GAMMA_B * (1 - PBAD));
	defineConstant("GAMMA_M", 1.0); // relative rate of patch "jitter"
	defineConstant("JITTER", GAMMA_M * (2 - PGOOD - PBAD));
	defineConstant("GROW_PROB", (1 - PGOOD) / (2 - PGOOD - PBAD));
	defineConstant("BAD_F", 0.25); // relative fecundity out of patches
	defineConstant("GOOD_F", 5.0); // relative fecundity in patches
	
	initializeMutationType("m1", 0.5, "g", 0.0, 2);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, G-1);
	initializeMutationRate(0.0);
	initializeRecombinationRate(1e-8);
	
	// grid to measure things on
	defineConstant("NGRID", asInteger(W));
	defineConstant("GRID", seq(0, W, length=NGRID));
	
	// spatial competition
	initializeInteractionType(1, "x", reciprocal=T, maxDistance=SI * 3);
	i1.setInteractionFunction("n", 1.0/(2*PI*SI^2), SI);
	
	// mate choice
	initializeInteractionType(2, "x", reciprocal=T, maxDistance=SM * 3);
	i2.setInteractionFunction("n", 1.0/(2*PI*SM^2), SM);

}

reproduction() {
	// choose our nearest neighbor as a mate, within the max distance
	mate = i2.drawByStrength(individual, 1);
	if (mate.size()) {
		nOff = rpois(1, FECUN * (BAD_F + GOOD_F * p1.spatialMapValue("patches", individual.spatialPosition)));
		individual.tag = individual.tag + nOff;  // DEBUG
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(1, 0.0, SD);
			if (p1.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p1.pointReflected(pos));
				offspring.tag = 0; // DEBUG
			}
		}
	}
	return;
}

1 early() {
	sim.addSubpop("p1", asInteger(K * W ));
	p1.setSpatialBounds(c(0, W));
	// random initial positions
	for (ind in p1.individuals) {
		ind.setSpatialPosition(p1.pointUniform());
		ind.tag = 0; // DEBUG
	}
	i1.evaluate();
	
	// map set-up
	init_patches = InitLandscape(NGRID);
	p1.defineSpatialMap("patches", "x", NGRID, init_patches, interpolate=F);
	
	// header info
	cat("gen" + " " + "stage" + " " + "age" + " " + "density");
	catn(" " + "neighbor" + " " + "harm_neigh" + " " + "num_off" + " " + "time");
}

early() {
	i1.evaluate(p1);
	inds = p1.individuals;
	competition = i1.totalOfNeighborStrengths(inds);
	inds.tagF = competition;  // DEBUG
	inds.fitnessScaling = pmin(0.95, 1/(1 + RHO * competition));
	// avoid edge effects
	inds.fitnessScaling = inds.fitnessScaling * pmin(sqrt(inds.x/SI), 1.0) * pmin(sqrt((W - inds.x)/SI), 1.0);
}

1: late() {
	// to be ready for mate choice
	i2.evaluate(p1);
}

1: late() {
	p1.defineSpatialMap("patches", "x", NGRID, UpdateLandscape(p1.spatialMapValue("patches", GRID)), interpolate=F);
}

2: early() {
	if ((sim.generation % 20) == 0) {
		cat(sim.generation + " " + "early" + " " + mean(p1.individuals.age) + " " + p1.individualCount/W^2);
		cat(" " + mean(p1.individuals.tagF) + " " + 1/mean(1/p1.individuals.tagF) + " " + mean(p1.individuals.tag));
		catn(" " + clock());
	}
}

2: late() {
	if ((sim.generation % 20) == 0) {
		cat(sim.generation + " " + "late " + " " + mean(p1.individuals.age) + " " + p1.individualCount/W^2);
		cat(" " + mean(p1.individuals.tagF) + " " + 1/mean(1/p1.individuals.tagF) + " " + mean(p1.individuals.tag));
		catn(" " + clock());
	}
	
	// DEBUG: GUI COLORS
	// green = many neighbors, few offspring so far
	// red = many offspring so far, few neighbors
	// yellow = many offspring so far, many neighbors
	max_n = max(1, max(p1.individuals.tag));
	max_f = max(0.01, max(p1.individuals.tagF));
	max_a = max(p1.individuals.age);
	for (ind in p1.individuals) {
		ind.color = rgb2color(c(ind.tag/max_n, ind.tagF/max_f, ind.age/max_a));
	}
}

1000 late() {
	sim.treeSeqOutput("sim.trees");
	sim.simulationFinished();
}
